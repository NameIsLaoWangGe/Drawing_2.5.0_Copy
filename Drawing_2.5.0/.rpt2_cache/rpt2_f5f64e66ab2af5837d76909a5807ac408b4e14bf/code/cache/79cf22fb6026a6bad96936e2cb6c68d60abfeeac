{
  "code": "import Tweener from \"./Tweener\";\r\nexport default class TweenMgr {\r\n    constructor() {\r\n        this.idle = [];\r\n        this.busy = {};\r\n        this.clearCounter = 0;\r\n    }\r\n    doStart() {\r\n        Laya.timer.frameLoop(1, this, this._update);\r\n        this.pause = false;\r\n    }\r\n    gamePause(state) {\r\n        this.pause = state;\r\n    }\r\n    _update() {\r\n        let busy = this.busy;\r\n        for (let id in busy) {\r\n            let t = busy[id];\r\n            if (!this.pause || t.ignoreTime) {\r\n                t._step(Laya.timer.delta);\r\n            }\r\n        }\r\n        this.clearCounter += 1;\r\n        if (this.clearCounter == 10) {\r\n            this.clearCounter = 0;\r\n            for (let id in busy) {\r\n                let t = busy[id];\r\n                if (t.hasClear) {\r\n                    delete busy[id];\r\n                    this.idle.push(t);\r\n                }\r\n            }\r\n        }\r\n    }\r\n    doTween(duration, update, complete, loopDir, auto, ignoreTime, ease, delay) {\r\n        let t = this.idle.pop() || new Tweener();\r\n        t._conf(duration, update, complete, loopDir, auto, ignoreTime, ease, delay);\r\n        this.busy[t.id] = t;\r\n        return t;\r\n    }\r\n    static start() {\r\n        TweenMgr.sg.doStart();\r\n    }\r\n    static clamp(v, min, max) {\r\n        let rs;\r\n        if (v < min) {\r\n            rs = min;\r\n        }\r\n        else if (v > max) {\r\n            rs = max;\r\n        }\r\n        else {\r\n            rs = v;\r\n        }\r\n        return rs;\r\n    }\r\n    static randomInRange_iWithOutY(x, y, s = null) {\r\n        let rs;\r\n        y = y - 1;\r\n        return this.randomInRange_i(x, y, s);\r\n    }\r\n    static randomInRange_f(x, y, s = null) {\r\n        let rs;\r\n        let g = y - x;\r\n        if (g < 0) {\r\n            throw `x > y`;\r\n        }\r\n        else {\r\n            if (g < TweenMgr.lim) {\r\n                rs = x;\r\n            }\r\n            else {\r\n                rs = g * (s == null ? Math.random() : s) + x;\r\n            }\r\n        }\r\n        return Number(rs);\r\n    }\r\n    static randomInRange_i(x, y, s = null) {\r\n        let rs;\r\n        if (x == y) {\r\n            rs = x;\r\n        }\r\n        else if (y > x) {\r\n            let v = (y - x) * (s == null ? Math.random() : s) + x;\r\n            rs = v.toFixed();\r\n        }\r\n        else {\r\n            throw `x > y`;\r\n        }\r\n        return Number(rs);\r\n    }\r\n    static tweenTiny(duration, caller, update, complete, ignoreTime = false, ease = Laya.Ease.linearNone, delay = 0) {\r\n        let t = TweenMgr.sg.doTween(duration, Laya.Handler.create(caller, update, null, false), complete && Laya.Handler.create(caller, complete, null, false), 0, true, ignoreTime, ease, delay);\r\n        t.play();\r\n    }\r\n    static tweenCust(duration, caller, update, complete, ignoreTime = false, ease = Laya.Ease.linearNone) {\r\n        return TweenMgr.sg.doTween(duration, Laya.Handler.create(caller, update, null, false), complete && Laya.Handler.create(caller, complete, null, false), 0, false, ignoreTime, ease, 0);\r\n    }\r\n    static tweenLoop(duration, caller, update, loopDir = 1, delay = 0, ease = Laya.Ease.linearNone, ignoreTime = false) {\r\n        return TweenMgr.sg.doTween(duration, Laya.Handler.create(caller, update, null, false), null, loopDir, false, ignoreTime, ease, delay);\r\n    }\r\n    static _getFactor(t) {\r\n        return Number(t.factor.toFixed(4));\r\n    }\r\n    static lerp_Num(start, end, t, group = 0) {\r\n        let inParams = t.getPG(\"inParams\", group);\r\n        if (inParams.length == 0) {\r\n            inParams[0] = start;\r\n            inParams[1] = end;\r\n        }\r\n        let outParams = t.getPG(\"outParams\", group);\r\n        outParams[0] = inParams[0] + (inParams[1] - inParams[0]) * TweenMgr._getFactor(t);\r\n    }\r\n    static lerp_Vec2(start, end, t, group = 0) {\r\n        let inParams = t.getPG(\"inParams\", group);\r\n        if (inParams.length == 0) {\r\n            inParams[0] = start.x;\r\n            inParams[1] = end.x - start.x;\r\n            inParams[2] = start.y;\r\n            inParams[3] = end.y - start.y;\r\n        }\r\n        let outParams = t.getPG(\"outParams\", group);\r\n        let f = TweenMgr._getFactor(t);\r\n        outParams[0] = inParams[0] + inParams[1] * f;\r\n        outParams[1] = inParams[2] + inParams[3] * f;\r\n    }\r\n    static lerp_Vec3(start, end, t, group = 0) {\r\n        let inParams = t.getPG(\"inParams\", group);\r\n        if (inParams.length == 0) {\r\n            inParams[0] = start.x;\r\n            inParams[1] = end.x - start.x;\r\n            inParams[2] = start.y;\r\n            inParams[3] = end.y - start.y;\r\n            inParams[4] = start.z;\r\n            inParams[5] = end.z - start.z;\r\n        }\r\n        let outParams = t.getPG(\"outParams\", group);\r\n        let f = TweenMgr._getFactor(t);\r\n        outParams[0] = inParams[0] + inParams[1] * f;\r\n        outParams[1] = inParams[2] + inParams[3] * f;\r\n        outParams[2] = inParams[4] + inParams[5] * f;\r\n    }\r\n    static lerp_Vec4(start, end, t, group = 0) {\r\n        let inParams = t.getPG(\"inParams\", group);\r\n        if (inParams.length == 0) {\r\n            inParams[0] = start.x;\r\n            inParams[1] = end.x - start.x;\r\n            inParams[2] = start.y;\r\n            inParams[3] = end.y - start.y;\r\n            inParams[4] = start.z;\r\n            inParams[5] = end.z - start.z;\r\n            inParams[6] = start.w;\r\n            inParams[7] = end.w - start.w;\r\n        }\r\n        let outParams = t.getPG(\"outParams\", group);\r\n        let f = TweenMgr._getFactor(t);\r\n        outParams[0] = inParams[0] + inParams[1] * f;\r\n        outParams[1] = inParams[2] + inParams[3] * f;\r\n        outParams[2] = inParams[4] + inParams[5] * f;\r\n        outParams[3] = inParams[6] + inParams[7] * f;\r\n    }\r\n    static lerp_Quat(start, end, t, group = 0) {\r\n        let inParams = t.getPG(\"inParams\", group);\r\n        if (inParams.length == 0) {\r\n            inParams[0] = start.x;\r\n            inParams[1] = start.y;\r\n            inParams[2] = start.z;\r\n            inParams[3] = start.w;\r\n            inParams[4] = end.x;\r\n            inParams[5] = end.y;\r\n            inParams[6] = end.z;\r\n            inParams[7] = end.w;\r\n        }\r\n        let f = TweenMgr._getFactor(t);\r\n        let ax = inParams[0], ay = inParams[1], az = inParams[2], aw = inParams[3], bx = inParams[4], by = inParams[5], bz = inParams[6], bw = inParams[7];\r\n        let omega, cosom, sinom, scale0, scale1;\r\n        cosom = ax * bx + ay * by + az * bz + aw * bw;\r\n        if (cosom < 0.0) {\r\n            cosom = -cosom;\r\n            bx = -bx;\r\n            by = -by;\r\n            bz = -bz;\r\n            bw = -bw;\r\n        }\r\n        if ((1.0 - cosom) > 0.000001) {\r\n            omega = Math.acos(cosom);\r\n            sinom = Math.sin(omega);\r\n            scale0 = Math.sin((1.0 - f) * omega) / sinom;\r\n            scale1 = Math.sin(f * omega) / sinom;\r\n        }\r\n        else {\r\n            scale0 = 1.0 - f;\r\n            scale1 = f;\r\n        }\r\n        let outParams = t.getPG(\"outParams\", group);\r\n        outParams[0] = scale0 * ax + scale1 * bx;\r\n        outParams[1] = scale0 * ay + scale1 * by;\r\n        outParams[2] = scale0 * az + scale1 * bz;\r\n        outParams[3] = scale0 * aw + scale1 * bw;\r\n    }\r\n}\r\nTweenMgr.lim = 1e-5;\r\n",
  "references": [
    "C:/Users/tomato/Desktop/Drawing_2.5.0/src/script/Frame/Tweener.ts"
  ]
}
